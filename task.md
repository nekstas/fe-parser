# Задание по парсерам

К КТ-1 мне главное, чтобы вы грамотным русским научным языком корректно описали поставленную задачу
и необходимый теоретический материал. ПЛЮС продвижения, если что-то уже успели изучить/сделать/подобрать
из вспомогательных библиотек.

Теоретический материал уже был на вводной теоретической лекции; ниже описание задач на оставшееся время.

## Самописный парсер

В этой части задачи нужно самостоятельно (без использования генераторов парсеров) написать парсер
и форматировщик для некоторого языка программирования.

* На вход передаётся единственный модуль, написанный на этом языке. Нужно распечатать его же,
  но отформатированным.

* Форматирование заключается в замене всех символов табуляций на пробелы, сортировке импортов,
  минимизации отступов и удалении лишних пробелов.

* Каждая строчка файла является самостоятельной единицей, в языке нет многострочных конструкций.

* В любой момент во входном файле могут встретиться команды импорта; в отформатированном файле
  они должны находиться в самом начале модуля, в котором они были вызваны, отсортированные лексикографически.

* Команды импорта имеют следующий синтаксис:
  ```
  import Module.Submodule.Subsubmodule (func1, func2)
  ```
  Либо такой:
  ```
  import Module.Submodule as M
  ```
  Либо такой:
  ```
  import Module.Submodule
  ```
  Где `Module`, `Submodule`, `Subsubmodule`, `M`, `func1`, `func2` &mdash; произвольные строчки из латинских символов и цифр,
  но не начинающиеся с цифры. `import` и `as` &mdash; ключевые слова, их нахождение в любом другом месте файла недопустимо.

* Кроме этого, модуль может содержать вложенные подмодули:
  ```
  module Submodule where
  ```
  Определения внутри подмодуля начинаются с отступа хотя бы на 2 пробела больше, чем отступ текущего модуля.
  Если определение начинается с меньшего отступа, оно считается частью родительского модуля с соответствующим
  отступом. Отступ, больший, чем у первого определения в модуле, не допускается. Ненулевой отступ в главном модуле
  (соответствующем самому файлу) не допускается.

* В каждом модуле на соответствующем отступе могут встречаться как объявления
  дочерних модулей, так и объявления функций и констант:
  ```
  let my_fun(x, y, z) := x + y + z
  let my_constant := my_fun(1, 2, 3)
  ```
  Справа от `:=` записано выражение (тело функции либо значение константы), составленное из применения арифметических операций
  (`+`, `-`, `*`, `/`, `^`), вызовов функций (`my_function(a, b, c)`), констант и переменных.
  Приоритеты и ассоциативности стандартные математические.

* После объявления функции опционально идёт блок `where`, открывающий модуль, ассоциированный с каждой функцией и константой
  (т.е. неявно с каждой функцией объявляется одноимённый модуль).

* в отформатированном файле в модулях, не имеющих непустых подмодулей, между объявлениями пустых строк нет.
  Во всех остальных модулях между объявлениями стоит ровно одна пустая строка. НО между импортами пустых строк нет.

* В отформатированном файле в объявлениях и вызовах функций после запятой стоит ровно один пробел,
  а вокруг арифметических операций стоит ровно один пробел. Лишних скобок стоять не должно.

* При сортировке импорты сортируются сначала по имени основного модуля (в `M1.M2.M3` это `M1`);
  далее &mdash; по первому подмодулю, и т.д. Родительские подмодули идут раньше своих детей,
  например `M1.M2` идёт раньше `M1.M2.M3`.

  Импорты одного и того же модуля через `as` сортируются лексикографически по псевдониму.

  Импорты сущностей из одного и того же модуля сливаются вместе и сортируются. Так, исходный файл с
  ```
  import M1.M2 (f3, f5)
  import M1 (f4, f2, f6)
  import M1 (f1)
  ```
  при сортировке превращается в
  ```
  import M1 (f1, f2, f4, f6)
  import M1.M2 (f3, f5)
  ```

### Пример

До форматирования:

```
module MyLinalg where
   import Unused

   let solve(A, b  )   :=   LA.solve( A  ,  b  )

   import numpy.linalg as LA


let some_root(a , b  , c  ) :=   (  b +   math.sqrt(( discriminant(a, b, c ) ) )) / a where

  let discriminant(   a, b,c   ) := (b ^ 2) - 4 * (a * c)


  import math
```

После форматирования:

```
module MyLinalg where
  import Unused
  import numpy.linalg as LA
  let solve(A, b) := LA.solve(A, b)

let some_root(a, b, c) := (b + math.sqrt(discriminant(a, b, c))) / a where
  import math
  let discriminant(a, b, c) := b ^ 2 - 4 * a * c
```